## 責務の整理：MVT+サービス+リポジトリ層

私たちが採用しているアーキテクチャは、従来の Django MVT パターンに、ビジネスロジックを独立させるための「サービス層」と、データアクセスを抽象化するための「リポジトリ層」を追加したものです。

これにより、各層の役割が明確になり、コードの分離と再利用性が向上しています。

---

### 1. データアクセス層 (Repository Layer)

**責務**: データソースとのやり取りを抽象化し、特定のモデルに対するデータ操作（CRUD）に専念します。ビジネスロジックは一切持ちません。

| 責務                       | 詳細な内容                                                                                                                                         | 例                                                                                       |
| :------------------------- | :------------------------------------------------------------------------------------------------------------------------------------------------- | :--------------------------------------------------------------------------------------- |
| **データアクセスの抽象化** | サービス層に対し、データソース（DB、外部 API など）の具体的な実装を隠蔽します。                                                                    | `M_UserRepository` は、`M_User` の取得・保存・更新といった純粋な DB 操作のみを担当する。 |
| **CRUD 操作の実行**        | Django ORM のクエリを直接発行し、データの永続化と取得を行います。                                                                                  | `get_user_by_email(email)`, `create_user_with_password(data)`                            |
| **例外の変換**             | データベース固有のエラー（`IntegrityError`など）を、アプリケーション全体で使用されるカスタム例外（`UserAlreadyExistsException`など）に変換します。 |

---

### 2. ビジネスロジック層 (Service Layer)

**責務**: アプリケーションのコアとなるビジネスロジックを実装します。複数のリポジトリやドメインルールを組み合わせて、一つの「ユースケース」を完成させます。

| 責務                                 | 詳細な内容                                                                     | 例                                                                                                                                   |
| :----------------------------------- | :----------------------------------------------------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------- |
| **ビジネスロジックの実装**           | 複雑なルール、状態遷移、複数のステップを伴う処理を定義します。                 | ユーザー登録時に「ユーザー作成」→「個人チーム作成」→「アクティベーションメール送信」という**一連の流れ（ユースケース）**を統制する。 |
| **リポジトリのオーケストレーション** | 必要なリポジトリを呼び出し、その結果を結合・加工します。                       | `AuthService` が、ユーザーを探すリポジトリと、トークンを保存するリポジトリの両方を利用してパスワードリセットを実行する。             |
| **トランザクション管理**             | 複数の DB 操作の原子性を保証するためのトランザクション境界を定義します。       | `register_new_user` メソッド全体に `@transaction.atomic` を適用する。                                                                |
| **ドメインルールの強制**             | ユーザーのステータスチェックや権限制御など、ビジネス上の制約をチェックします。 | 非アクティブユーザーのログインを拒否し、`AccountLockedException` を発生させる。                                                      |

#### サービス関数の単位：ユースケース

サービス層の関数は、**一つの完全なビジネス上の操作（ユースケース）**を表現する単位であり、API エンドポイントの単位とは目的が異なります。

| 単位の目的             | 詳細                                                                                                                                                        |
| :--------------------- | :---------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **ビジネス上の完全性** | 処理の成功に必要な全てのステップ（複数の DB 操作、外部通信など）を統合し、データの一貫性（トランザクション）を保証します。**HTTP 操作の概念は含みません。** |
| **再利用性**           | Web API、CLI ツール、バッチ処理など、**あらゆるインターフェース**から呼び出せるように設計されており、特定の技術に依存しません。                             |

---

### 3. プレゼンテーション層 (View/Controller)

**責務**: 外部からのリクエストを受け付け、サービス層へ処理を委譲し、その結果を HTTP レスポンスとして返す役割に特化します。ビジネスロジックは一切含みません。

| 責務                                | 詳細な内容                                                                                                                                                                        | なぜ View が担うか？                                                                 |
| :---------------------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------- |
| **リクエストの受付と処理**          | HTTP リクエストを受け付け、クエリパラメータやリクエストボディを抽出します。                                                                                                       | Web アプリケーションのフロントエンドインターフェースであるため。                     |
| **データの検証と変換**              | DRF (Django Rest Framework) の**Serializer**を使用して、受け取ったデータが構造的に正しいか検証し、Python オブジェクトに変換します。                                               | サービス層に渡す前に、データが整っていることを保証するため。                         |
| **サービス層への委譲 (Delegation)** | 抽出・検証済みのデータを引数として、適切なサービスメソッド（ユースケース）を呼び出します。**View は、何を行うか**をサービスに伝えます。                                           | View からビジネスロジックを分離し、View の役割を純粋なコントローラーに限定するため。 |
| **例外処理と HTTP 変換**            | サービス層から発生したカスタム例外（例: `PasswordResetTokenInvalidException`）を捕捉し、適切な HTTP ステータスコード（400 Bad Request や 404 Not Found など）に変換して返します。 | アプリケーション内部のドメイン例外を、外部の HTTP プロトコルルールに変換する役割。   |
| **レスポンスの生成**                | サービス層から返された結果データを、DRF **Serializer**を使用して JSON 形式などに変換し、HTTP レスポンスを生成します。                                                             | クライアントへ結果を返す最終ステップ。                                               |
| **HTTP 固有のデータ設定**           | **レスポンスの形式（JSON/HTML）とは別に、HTTP プロトコル特有のメタデータを設定します。**                                                                                          | View/Controller が Web の外部インターフェース管理に責任を持つため。                  |

#### Cookie の設定における責務

Cookie の設定は、**サービス層のビジネスロジックではなく、View 層（プレゼンテーション層）の責務**です。

| 責務 (View 側)                   | 内容                                                                                                       | 理由                                                                                 |
| :------------------------------- | :--------------------------------------------------------------------------------------------------------- | :----------------------------------------------------------------------------------- |
| **Cookie 設定の実行**            | サービス層から受け取った文字列（リフレッシュトークンなど）を使い、`HttpResponse.set_cookie()` を実行する。 | Cookie は HTTP レスポンスヘッダーの一部であり、Web プロトコルに依存するため。        |
| **セキュリティオプションの適用** | `HttpOnly=True` や `Secure=True` などのセキュリティオプションを適用する。                                  | 認証情報の盗難を防ぐためのセキュリティ設定は、プレゼンテーション層の管轄であるため。 |

#### View とサービス関数の関係性

API エンドポイント（View）の単位は**HTTP 操作の境界**を、サービス関数の単位は**ビジネス操作の完全性**を表します。

| 関係性                | 詳細                                                                                                                                          |
| :-------------------- | :-------------------------------------------------------------------------------------------------------------------------------------------- |
| **一対一対応 (主流)** | クライアントからのリクエストが単一のビジネス目的（例: `POST /login`）を持つため、多くの場合、View とサービス関数は一対一で対応します。        |
| **View の目的**       | HTTP リクエストをサービス関数に渡すという**制御**に徹すること。ビジネスロジックの断片を View に持たせないことが、このアーキテクチャの鍵です。 |

---

### 4. MVT 層 (Model / Template)

| 層           | 責務                                                                                                                                                                         |
| :----------- | :--------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| **Model**    | データベースのスキーマ定義、データ型の定義、フィールドレベルの検証、モデル間のリレーションシップ定義など、純粋なデータ構造を定義します。                                     |
| **Template** | ユーザーインターフェースの表示（HTML レンダリング）を担当します。View から渡されたデータを受け取り、最終的な見た目を生成します。（API 開発では通常、この層は使用しません。） |
